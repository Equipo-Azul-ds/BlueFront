### gameSession ENDPOINTS and EVENTS:
Motor de Juego en Vivo (Síncrono) - LISTO 90%, faltan eventos extra de UX, por favor no esperar al 100%, a lo mejor ni llego a poder meter esos eventos extra
Endpoints solicitudes HTTP 
Elemento
	Detalle
	Propósito Específico
	El Anfitrión crea una nueva sala de juego (Lobby) a partir de un Kahoot existente. (H4.1). Le provee de todo lo necesario para disponer la sala de espera (lobby).
	Método HTTP
	POST
	Request Path
	/multiplayer-sessions
	Headers
	Authorization: Bearer <JWT> // Contiene el userId para crear la sesión
	Request Body
	Objeto JSON con el id del kahoot
	Response (201 Created)
	Se crea exitosamente la nueva sala de juego
	Esqueleto JSON (Request)
	JSON {
  "kahootId": "uuid",
}
	Esqueleto JSON (Response)
	JSON { 
"sessionPin": "238972990", 
"qrToken": "uuid",
"quizTitle": string, 
"coverImageUrl": string (url),
"theme": {
   "id": string (uuid),
   "url": string (url) , 
   "name": string
}
NOTA: El pin de sesión es un número (como string) entre 6 y 10 dígitos, el qrToken es un uuid, el cual actúa como un identificador que permite obtener el pin de la sesión. Este uuid del qrToken es lo que el front debe convertir en un código QR, que al escanearlo permita obtener ese mismo uuid.


El theme es la imagen del fondo de la partida, corresponde al theme del kahoot y se puede cambiar en cualquier momento de la partida por otro disponible en un set de temas predeterminados.
	Error
	404 Not Found: El Kahoot no existe
401 Unauthorized: El usuario autenticado (Host) no tiene permisos para crear una sesión con el Kahoot solicitado.
500 Internal Server Error: Fallo al generar número aleatorio después de X intentos.


NOTA: Ante error 500 con ese mensaje, es recomendable volver a realizar la petición sin que el usuario se entere, el PIN debería acabar generándose a los pocos intentos
	________________




Elemento
	Detalle
	Propósito Específico
	Permite a un cliente obtener el sessionPin de una partida activa al escanear un código QR que contiene un token o identificador único. (H4.3)
	Método HTTP
	GET
	Request Path
	/multiplayer-sessions/qr-token/:qrToken
	Request Body
	No aplica
	Response (200 OK)
	Se obtuvo el pin de la partida exitosamente al escanear el código QR para unirse a la partida
	Esqueleto JSON (Request)
	No aplica
	Esqueleto JSON (Response)
	JSON { 
    "sessionPin": "number (El PIN de entre 6 y 10 dígitos)",
}
NOTA: El cliente debe usar el gamePin devuelto para hacer el handshake inicial con el namespace y así unirse a la sala a nivel de infraestructura
	Error
	404 Not Found: El código QR o token no está asociado a una sesión activa.
	











Namespace y eventos para el manejo de WebSockets
Elemento
	Detalle
	Propósito Específico
	Permite a Hosts y Jugadores conectarse a una sala de juego a través del PIN de la misma y recibir actualizaciones en tiempo real del estado del Lobby y la partida.
	Namespace/Ruta
	/multiplayer-sessions
	Dependencia (Autenticación)
	Requiere los siguientes parámetros de conexión como headers para hacer join con la sala en cuestión:


    pin: ‘123456’ // Pin de la sesión
    role: 'HOST' //Enum: ‘HOST’ o ‘PLAYER’ 
    jwt: 'jwt-del-host' // JWT, el cual contiene el id del usuario y su username


	

Conexión y Gestión del Lobby
Eventos enviados Por el Cliente
Evento de Entrada
	client_ready
	Propósito
	Establecer la sincronización lógica entre el cliente (Host o Jugador) y el servidor. Este evento actúa como una señal de confirmación para que el servidor inicie la transmisión de datos de estado.
Su función principal es garantizar que el cliente ha completado la configuración de sus "listeners" (escuchadores de eventos) antes de recibir cualquier información crítica. Es el mecanismo de seguridad para evitar la pérdida de eventos durante el handshake inicial o en procesos de reconexión.
Nota técnica: Este evento debe ser emitido obligatoriamente por el cliente sólo después de haber suscrito todos los eventos necesarios del servidor. De lo contrario, los datos de sincronización inicial podrían no ser capturados por la interfaz.


	Emisor
	Host y Jugador.
	Payload Requerido
	No Aplica
	Respuestas del Servidor
	El servidor no responde con un "ACK" genérico, sino que dispara el proceso de sincronización basado en el rol y el estado actual de la partida:
A. En caso de Éxito (Solo inicio de la partida): Dependiendo del rol identificado en el socket, el servidor emitirá una ráfaga de eventos con el estado actual:
* Para el HOST:
   * HOST_CONNECTED_SUCCESS: Confirmación de ingreso administrativo a la sala.
   * HOST_LOBBY_UPDATE: Estado actual de todos los jugadores conectados y configuraciones de la sala.
* Para el JUGADOR:
   * PLAYER_CONNECTED_TO_SESSION: Estado específico del jugador, su puntuación y fase actual de la partida (lobby).
B. En caso de Reconexión (Partida avanzada / en curso)
Si el cliente se reconecta cuando la sesión ya ha superado la etapa del Lobby, el servidor detectará el estado actual del juego y enviará un Snapshot de Sincronización.
Dependiendo del rol y la fase de la partida, el servidor emitirá los eventos específicos que el cliente necesita para reconstruir la interfaz inmediatamente, tales como:
* QUESTION_STARTED: Si hay una pregunta activa en curso (incluyendo tiempo restante y datos de la pregunta).
* PLAYER_RESULTS / HOST_RESULTS: Si el cliente vuelve justo en la pantalla de puntajes.
* HOST_GAME_END / PLAYER_GAME_END: Si la partida finalizó durante su ausencia.
Propósito Técnico: Evitar que un usuario reconectado se quede en una "pantalla negra" esperando al siguiente evento global. El servidor lo fuerza a sincronizarse con el tiempo real de la sala.
C. En caso de Error:
* SYNC_ERROR: Se emite únicamente al cliente solicitante si ocurre un fallo al recuperar el estado del dominio (ej. la sala dejó de existir durante el proceso). Tras este evento, el servidor cerrará la conexión por seguridad.


	

Evento de Entrada
	player_join
	Propósito
	Un jugador se une a la sesión dando el nickname que tendrá durante la misma. En este punto el jugador se conecta finalmente a nivel de lógica de negocio (dominio).


El cliente puede reutilizar este evento para cambiar su nickname en caso de haberse desconectado de la partida, haberse sincronizado con la sesión aún en lobby, y desear cambiar el nickname de su entrada actual.*
	Emisor
	Jugador.
	Payload Requerido
	JSON { 
  "nickname": string, 
}


NOTA: El nickname debe ser un string de entre 6-20 caracteres
	Respuestas del Servidor
	Éxito: host_lobby_update (solo al host) y player_connected_to_session (solo al cliente, es decir el emisor)
Error: connection_error (solo al emisor)
	*Nota particular sobre player_join: A nivel de dominio el jugador siempre se quedará registrado para posibilitar su regreso una vez haya hecho su primer player_join. Si vuelve durante la etapa de LOBBY, se volverán a cargar sus datos al emitir el evento client_ready recibiendo como respuesta o un player_lobby_update, en ese punto el front, sí quiere, y solamente durante esta etapa, puede ofrecerle al usuario cambiar su nickname. Si esto es así, debe volver a emitir el evento player_join para cambiar su nickname.


Evento de Entrada
	host_start_game
	Propósito
	El Host inicia formalmente el juego desde el estado de LOBBY.
	Emisor
	Host/Anfitrión.
	Payload Requerido
	No aplica
	Respuestas del Servidor
	Éxito: question_started (Broadcast a todos)


Error: game_error (Respuesta solo al emisor)
	________________


Eventos enviados Por el Servidor
Evento de Salida
	host_lobby_update
	Propósito
	Notifica al host del estado del lobby: jugadores conectados y cuántos hay en la sala
	Receptores
	Host
	Payload (Output)
	JSON {
  "state": "lobby",
   "players": [
     {
        "playerId": string (uuid),
        "nickname": "Player 1"
     },
    {
        "playerId": string (uuid),
        "nickname": "Player 2"
     }
    ],
    "numberOfPlayers": 2
}
	

Evento de Salida
	player_connected_to_session
	Propósito
	Notifica al jugador de que está conectado a la partida a nivel de negocios (dominio), está registrado y se le pasa su información actualizada para la pantalla de espera/lobby. 
	Receptores
	Jugador
	Payload (Output)
	JSON {
    "state": "lobby",
    "nickname": "Player 1",
    "score": 0 (Siempre debería ser 0),
    "connectedBefore": boolean , //Para saber si ya se había unido antes al lobby
}
	Flujo de Preguntas y Respuestas
Eventos enviados Por el Cliente
Evento de Entrada
	player_submit_answer
	Propósito
	Un jugador envía su respuesta a la pregunta actual.
	Emisor
	Jugador.
	Payload Requerido
	JSON { 
  "questionId": "uuid" // id de la slide actual que se está jugando, 
  "answerId": ["1", "0", "2"], 
  "timeElapsedMs": number
}
Nota: timeElapsedMs es el tiempo que tardó en responder el usuario, el front debería hacerlo mediante un cálculo de dos Dates: timeElapsedMs = End - Start. Se pasa un arreglo de answerId para poder soportar slides tipo selección múltiple, este mismo es el id de la respuesta, es requerido, y  no se debe validar si es un Index o un UUID
	Respuestas del Servidor
	Éxito: player_answer_confirmation (Solo al emisor) y host_answer_update (solo al host)
Error: game_error (Respuesta solo al emisor)
	





Evento de Entrada
	host_next_phase
	Propósito
	El Host avanza manualmente la sesión a la siguiente fase (ej. de resultados a la siguiente pregunta, de pregunta a resultados, o de resultados a fin).
	Emisor
	Host/Anfitrión.
	Payload Requerido
	No aplica
	Respuestas del Servidor
	Éxito: 
host_results y player_results (QUESTION → RESULTS), 
question_started (RESULTS → QUESTION) ,  
host_game_end y player_game_end (RESULTS → END) 
(Broadcast a todos)
	________________




Evento de Entrada
	host_end_session
	Propósito
	Cerrar la sesión, y por tanto cerrar a su vez la sala de juego y desconectar a los jugadores de la partida. Este evento lo emite manualmente el host tras la emisión del evento host_end_game por parte del servidor
	Emisor
	Host/Anfitrión.
	Payload Requerido
	No aplica
	Respuestas del Servidor
	Éxito: 
session_closed  (Broadcast a todos)
	________________


Eventos enviados Por el Servidor
Evento de Salida
	question_started
	Propósito
	Notifica a los jugadores que una pregunta ha comenzado y tienen un tiempo límite para responder. Incluye los datos completos de visualización de la slide para que el cliente pueda renderizarla al instante.
	Receptores
	Todos los Jugadores y Host.
	Payload (Output)
	JSON {
   “state”: “question”
   "currentSlideData": { 
      "id": "uuid", 
      "position": number, 
      "slideType": "Enum question_type", 
      "timeLimitSeconds": number,
      "questionText": "text",
      "slideImageURL": "url",
       "pointsValue": number, 
       "options": [ 
{ "index": “1” , "text": "Paris" | Null, “mediaURL”: String(URL) | null },
{ "index": “2” , "text": "Tokio"  | Null, ”mediaURL”: String(URL) | null }
       ] 
    }
      "timeRemainingMs": number (Opcional), 
      "hasAnswered": boolean (Opcional), 
}
Nota: position (índice del slide), se envía para que el front sepa en qué parte de la partida va, es decir en qué slide está parado en ese momento el servidor. En las options no se manda cuál es la opción correcta pues la verificación de eso lo hace el servidor.
timeRemainingMs y hasAnswered son opcionales pues solo se envían como apéndice luego de un Client_Ready tras reconexión en medio de una pregunta. Time remaining es para colocar el contador con el tiempo restante verdadero, y hasAnswered para bloquear que el jugador de otra respuesta. El host solo recibe el atributo timeRemaingMs ya que este no responde preguntas.
	



Evento de Salida
	host_results
	Propósito
	Muestra el resumen de la pregunta para un HOST (respuesta correcta, distribución de respuestas y el ranking de puntajes).
	Receptores
	Host.
	Payload (Output)
	JSON {
    "state": "results",
    "correctAnswerId": [ "0", "2" ],
    "leaderboard": [
        {
            "playerId": "uuid",
            "nickname": "Player1",
            "score": number,
            "rank": number,
            "previousRank": number
        },
        {
            "playerId": "uuid",
            "nickname": "Player2",
            "score": number,
            "rank": number,
            "previousRank": number
        }
    ],
    "stats": {
        "totalAnswers": 2,
        "distribution": {
            "0 | uuid": number,
            "1 | uuid": number,
            "2 | uuid": number,
            "3 | uuid": number,
            …,
        }
    },
    "progress": {
        "current": number,
        "total": number,
        "isLastSlide": boolean
    }
}


NOTA: Se pasa un arreglo de correctAnswerId para poder soportar slides tipo selección múltiple. El atributo distribution es un objeto cuyas llaves son los uuid o los índices de las opciones de respuesta, esto nos ayuda a ver cuál fue la distribución de opciones elegidas como respuestas. En el atributo leaderboard recibimos solamente el top 5.
	

Evento de Salida
	player_results
	Propósito
	Muestra el resumen de la pregunta para un PLAYER (respuesta correcta, posición en el ranking, streak, y mensajes de motivación).
	Receptores
	Jugador: Cada jugador recibe individualmente su propia respuesta según lo que haya respondido en la ronda.
	Payload (Output)
	JSON {
    "isCorrect": boolean,
    "pointsEarned": number,
    "totalScore": number,
    "rank": number,
    "previousRank": number,
    "streak": number,
    "correctAnswerIds": [
        "0",
        "2"
    ],
    "message": string,
    "progress": {
        "current": number,
        "total": number
    }
}




NOTA: Se pasa un arreglo de correctAnswerId para poder soportar slides tipo selección múltiple.
	Nota: Justo antes de emitirse estos eventos de Finalización, el Servidor inicia automáticamente el proceso asíncrono de persistir toda la información de la partida (puntajes, respuestas y metadata) bajo el id del kahoot y del id de la sesión para futuras consultas en el módulo de Informes.
Evento de Salida
	host_game_end
	Propósito
	Marca el final de la sesión de juego y envía el podium final al HOST. 
	Receptores
	Host.
	Payload (Output)
	JSON{
    "state": "end",
    "finalPodium": [
        {
            "playerId": "uuid",
            "nickname": "Player1",
            "score": number,
            "rank": number,
            "previousRank": number
        },
        {
            "playerId": "uuid",
            "nickname": "Player2",
            "score": number,
            "rank": number,
            "previousRank": number
        },
        {
            "playerId": "uuid",
            "nickname": "Player3",
            "score": number,
            "rank": number,
            "previousRank": number
        }
    ],
    "winner": {
        "playerId": "897115b0-e3ff-4448-ac06-58584df826ea",
        "nickname": "Player1",
        "score": number,
        "rank": number,
        "previousRank": number
    },
    "totalParticipants": number
}
NOTA: En finalPodium recibimos solamente el Top 3 de jugadores en base a sus puntajes 
	

Evento de Salida
	player_game_end
	Propósito
	Marca el final de la sesión de juego y envía el resumen final respectivo de cada PLAYER. 
	Receptores
	Jugador: Cada jugador recibe individualmente su propia respuesta a modo de resumen de la partida.
	Payload (Output)
	JSON {
    "state": "end",
    "rank":  number,
    "totalScore": number,
    "isPodium": boolean,
    "isWinner": boolean,
    "finalStreak": number
}
	________________


Evento de Salida
	session_closed
	Propósito
	Notificar a todos los involucrados del cierre de la sesión para una desconexión segura y alineada con una buena UX
	Receptores
	Todos: jugadores y host
	Payload (Output)
	JSON {
      reason: “HOST_CLOSED_SESSION”,
      message: “El anfitrión ha finalizado la sesión.”
 }


	

Evento de Salida
	player_left_session
	Propósito
	Notificar de manera proactiva al Host (y opcionalmente a la sala) que un jugador ha perdido la conexión o ha abandonado la sesión.
El objetivo es permitir que la interfaz del Host actualice la lista de jugadores activos en tiempo real, permitiéndole identificar quiénes han tenido problemas técnicos o quiénes han abandonado voluntariamente. Esto es crucial para la toma de decisiones del Host (ej. decidir si esperar a alguien para empezar o continuar la partida).
Nota: Se recomienda al Frontend del Host no eliminar inmediatamente al jugador de la lista visual, sino marcarlo como 'Desconectado' (ej. en gris) durante el periodo de espera de reconexión.
	Receptores
	Host
	Payload (Output)
	JSON { 
     “userId”: string (uuid),
     “nickname”: string,
     “message”: “El jugador ${nickname} se ha desconectado.”
 }




	

Evento de Salida
	host_left_session
	Propósito
	Notificar a los jugadores que el host se ha desconectado
	Receptores
	Jugadores
	Payload (Output)
	JSON { 
     “message”: “El host ha abandonado la sesión por favor espere"
 }




	

Evento de Salida
	host_returned_to_session
	Propósito
	Notificar a los jugadores que el host ha recuperado la conexión con la sesión
	Receptores
	Jugadores
	Payload (Output)
	JSON { 
     “message”: “El host ha recuperado la conexión con la sesión"
 }


	

Evento de Salida
	host_answer_update
	Propósito
	Notificar al host de cuantas respuestas van siendo registradas para una slide durante la etapa de QUESTION
	Receptores
	Host
	Payload (Output)
	JSON { 
     “numberOfSubmissions”: number
 }


	________________


Nota: A continuación se adjunta una tabla con una explicación más detallado de los estados de la partida:
Estado (Enum)
	Propósito
	Transiciones Comunes
	LOBBY
	Esperando jugadores: El recurso de juego existe, el PIN está activo, pero la partida aún no ha comenzado. Es el punto de entrada para los jugadores.
	→ QUESTION (Al hacer host_start_game)
	QUESTION
	Interacción principal: La fase donde se activa el temporizador y se espera la entrada del jugador (la respuesta).
	→ RESULTS (Al terminar el tiempo o por host_next_phase)
	RESULTS
	Retroalimentación y Clasificación: El jugador no interactúa, sino que recibe feedback sobre la pregunta anterior (respuesta correcta) y ve la actualización de su puntuación y el ranking general en la pantalla del host.
	→ QUESTION (Si quedan preguntas) o →  END (Si fue la última pregunta).
	END
	Fin del juego: El juego ha concluido formalmente y se muestra el podio final en la pantalla del host.
	→ Cerrar Conexión (El recurso se libera).
	________________

### report feature endpoints
Informes, Estadísticas y Feedback
1. Obtener Informe de Sesión (Anfitrión) (H10.1, H10.2)
Elemento
	Detalle
	Propósito Específico
	Ver el reporte ordenado de resultados de una sesión (H10.1) y el análisis por pregunta (H10.2). Estos son los resultados generales de la sesión. No son para un jugador específico. Para obtener la sessionId hacer GET reports/kahoots/my-results (te da los ids de cada intento).
	Método HTTP
	GET
	Request Path
	/reports/sessions/:sessionid
	Response Status
	200 OK
	Response Body (DTO)
	SessionReportDto (DTO Complejo)
	Esqueleto JSON (Response)
	{ "reportId": "uuid", "sessionId": "uuid-sesion", "title": "string", "executionDate": "datetime", "playerRanking": [ { "position": 1, "username": "string", "score": 9500, "correctAnswers": 9 }, ... ], "questionAnalysis": [ { "questionIndex": 0, "questionText": "string", "correctPercentage": 0.85 }, ... ] }
	Error
	401 Unauthorized (Usuario no autenticado).
403 Forbidden (Usuario no es el anfitrión/creador de este reporte).
404 Not Found (Reporte/Sesión :id no encontrado).
	



2. Obtener Resultados Personales de un Quiz (Multijugador) (H10.3)
Elemento
	Detalle
	Propósito Específico
	Ver resultados personales (puntuación, aciertos) de un Kahoot específico multijugador completado (H10.3). Para obtener el sessionId hacer GET reports/kahoots/my-results (te da los ids de cada intento).
	Método HTTP
	GET
	Request Path
	/reports/multiplayer/:sessionid
	Response Status
	200 OK
	Response Body (DTO)
	PersonalResultDto
	



Esqueleto JSON (Response)
	







{ "kahootId": "uuid-kahoot-1", "title": "string", "userId": "uuid-me", "finalScore": 8200, "correctAnswers": 8, "totalQuestions": 10, "averageTimeMs": 6100, "rankingPosition": 5,
"questionResults": [{ "questionIndex": 0, "questionText": "Cuál es la capital de Francia?", "isCorrect": true, answerText": String[ ], “answerMediaID”: “String[ ]" (URLarray), "timeTakenMs": 4500 },...]
}


Nota: Hay answerText y answerMediaID porque una respuesta puede tener o texto o una imagen. Son mutuamente excluyentes. Adicionalmente se manda un array de respuestas por cada pregunta para cubrir el caso multiple choice. 


Como se maneja en el front:


Por cada pregunta al front le llegara un array de answerText y un array de answerMediaID, como una respuesta sólo puede tener una de ambas (o texto o imagen), cada elemento de cualquiera de ambos arrays cuenta como una respuesta distinta seleccionada por el usuario (de nuevo para cubrir multiple choice), si ambos arrays llegan vacíos quiere decir que el usuario no seleccionó ninguna respuesta.


El front debe ser flexible para poder modelar tanto imagenes como texto para las respuestas seleccionadas.


	Error
	401 Unauthorized (Usuario no autenticado).
404 Not Found (Kahoot :id no encontrado, o el usuario actual no tiene resultados para ese kahoot).
	



Elemento
	Detalle
	Propósito Específico
	Ver resultados personales (puntuación, aciertos) de un Kahoot específico singleplayer completado (H10.3). Para obtener el attempt id se debe hacer get reports/kahoots/my-results (te da los ids de cada intento).
	Método HTTP
	GET
	Request Path
	/reports/singleplayer/:attemptId
	Response Status
	200 OK
	Response Body (DTO)
	PersonalResultDto
	



Esqueleto JSON (Response)
	{ "kahootId": "uuid-kahoot-1", "title": "string", "userId": "uuid-me", "finalScore": 8200, "correctAnswers": 8, "totalQuestions": 10, "averageTimeMs": 6100, "questionResults": [{ "questionIndex": 0, "questionText": "Cuál es la capital de Francia?", "isCorrect": true, answerText": String[ ], “answerMediaID”: “String[ ]" (URLarray), "timeTakenMs": 4500 },...]
}


Nota: Hay answerText y answerMediaID porque una respuesta puede tener texto o una imagen. Son mutuamente excluyentes. Adicionalmente se manda un array de respuestas por cada pregunta para cubrir el caso multiple choice. 


Como se maneja en el front:


Por cada pregunta al front le llegara un array de answerText y un array de answerMediaID, como una respuesta sólo puede tener una de ambas (o texto o imagen), cada elemento de cualquiera de ambos arrays cuenta como una respuesta distinta seleccionada por el usuario (de nuevo para cubrir multiple choice), si ambos arrays llegan vacíos quiere decir que el usuario no seleccionó ninguna respuesta.


El front debe ser flexible para poder modelar tanto imagenes como texto para las respuestas seleccionadas.


Nota 2: Este response es igual que el de multiplayer pero sin rankingPosition. (Porq es solo play)
	Error
	401 Unauthorized (Usuario no autenticado).
404 Not Found (Kahoot :id no encontrado, o el usuario actual no tiene resultados para ese kahoot).
	



3. Obtener Lista de los Resultados Personales de los Quices (Jugador) (H10.3)
Elemento
	Detalle
	Propósito Específico
	Obtener un listado de los resultados personales de los Kahoots en los que el usuario haya participado. Cada kahoot puede tener multiples registros de partida. Se incluye un identificador gameType en cada uno que indica si la partida fue singlePlayer o Multiplayer, además se incluye el sessionId o attemptId segun corresponda. 
	Método HTTP
	GET
	Request Path
	/reports/kahoots/my-results
	Query Params
	limit (opcional): number - Límite de resultados (default: 20)
page (opcional): number - Página actual (default: 1)
	Response Status
	200 OK
	Response Body (DTO)
	KahootResultSummaryDto[]
	Esqueleto JSON (Response)
	{ "results": [ { "kahootId": "uuid-kahoot-1", “gameId”: UUID, “gameType = "Singleplayer" | "Multiplayer", ”title": "string", "completionDate": "datetime", "finalScore": 8200, "rankingPosition": 5 | Null }, ... ], "meta": { "totalItems": 80, "currentPage": 1, "totalPages": 8 , “limit”:10} 
El front debe revisar que tipo de juego es cada intento (con gameType) y de acuerdo a eso sabrá si el id de juego recibido (gameId) corresponde a un attemptid (singleplayer) o a un sessionid (para multiplayer). Con estos ids se puede hacer consulta a reports/multiplayer/sessionid y reports/singleplayer/attemptid para obtener los detalles especficos de un intento.
Nota: Para los kahoots individuales no se proporcionara rankingPosition. 
	Error
	401 Unauthorized (Usuario no autenticado).
400 Bad Request (Parámetros de query inválidos)